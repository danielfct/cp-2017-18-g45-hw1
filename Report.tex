\documentclass[a4paper]{article}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=3cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

\title{Concorrência e Paralelismo \\
\large Projecto 1}

\author{Didier Dias N45777\and Daniel Pimenta N}

\begin{document}
\maketitle

\begin{abstract}
O problema principal que foi resolvido foi a paralelização de um programa que simula um jogo de reversi, fornecido pelo professor. \\
Para tal foi utilizada a técnologia Cilk+ que nos permite facilmente criar threads em paralelo, podendo assim o computador utilizar vários cores para realizar o processamento do programa.\\
Foi nos possível realizar esta paralelização o que, se o  tamanho do tabuleiro utilizado na simulação for de um tamanho relevante, diminui bastante o tempo de execução do programa.
\end{abstract}

\section{Introdução}

Foi-nos fornecido um programa em C que simula um jogo de reversi, estando este implementado iterativamente. O problema consiste em tentar paralelizar esse código, fazendo as alterações necessárias para esse efeito. Foram também feitas algumas otimizações de modo a que o programa corra o mais rápidamente possivel, sem sacrificar a estabilidade do mesmo.\\
Para poder efetuar estas mudanças é preciso saber quais são as partes do código que podem ser paralelizadas, ou seja, partes que nao entrem em conflito seja ao alterar a mesma posição de memória ao mesmo tempo ou mesmo manter a ordem dos métodos, no caso em que esta seja necessária.\\\\
What	is	the	general	
approach/strategy	you	 followed	 to	have	 the	program	executing	correctly	multithreaded?

\section{Método}
De modo a distribuir o trabalho pelos threads existentes foram feitas várias alterações ao código inicial.\\ 
Uma dessas alterações foi bastante simples, a obtenção de todos os movimentos possíveis. Isto deve-se à maneira como esta pesquisa está implementada, cada posição do tabuleiro é verificada se contém uma possivel jogada e qual a pontuação associada a esta. 
Visto que apenas estamos a aceder a diferentes posições da matriz "board" para ver qual o estado da casa e, casa seja possivel executar essa jogada, a colocar esse novo "move" numa outra matriz "m", que contém todos as jogadas possiveis, não irá existir qualquer colisão durante a execução das threads. Como tal, podemos simplesmente utilizar o cilk\_for para paralelizar este troço de código. 
\\\\ A	longer	section	describing	your	solution.	How	did	you	split	the	work	
among	 threads?	What	parallel	pattern(s)	did	you	use?	 What	problems	did	you	
identify	 when	 parallelizing	 the	 given	 code?	 	 How	 did	 you	 address/solve	 them?	
IMPORTANT:	 by reading	 this	 section	 it	must	 be	 clear	 how	 your	 solution	works,	
making	it	also	clear	why	it	works.	After	reading	this	section,	another	programmer	
should	be	able	to	re-implement	your	solution	without	looking	at	your	source	code

\section{Validação}

\section{Avaliação}

\section{Conclusões}

\section{Acknowledgments}
\begin{itemize}
\item André Neves - Nº46264
\begin{itemize}
\item Discussão sobre várias maneiras de implementar a paralelização, nomeadamente se seria melhor recursivamente ou iterativamente e sobre os vários padrões de paralelização e sobre qual o mais correto para esta situação.
\end{itemize}

\end{itemize}

\section{Bibliografia}

\end{document}