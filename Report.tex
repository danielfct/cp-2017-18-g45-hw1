\documentclass[a4paper]{article}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=3cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

\title{Concorrência e Paralelismo \\
\large Projecto 1}

\author{Didier Dias N45777\and Daniel Pimenta N}

\begin{document}
\maketitle

\begin{abstract}
O problema principal que foi resolvido foi a paralelização de um programa que simula um jogo de reversi, fornecido pelo professor. \\
Para tal foi utilizada a técnologia Cilk+ que nos permite facilmente criar threads em paralelo, podendo assim o computador utilizar vários cores para realizar o processamento do programa.\\
Foi nos possível realizar esta paralelização o que, se o  tamanho do tabuleiro utilizado na simulação for de um tamanho relevante, diminui bastante o tempo de execução do programa.
\end{abstract}

\section{Introdução}

Foi-nos fornecido um programa em C que simula um jogo de reversi, estando este implementado iterativamente. O problema consiste em tentar paralelizar esse código, fazendo as alterações necessárias para esse efeito. Foram também feitas algumas otimizações de modo a que o programa corra o mais rápidamente possivel, sem sacrificar a estabilidade do mesmo.\\
Para poder efetuar estas mudanças é preciso saber quais são as partes do código que podem ser paralelizadas, ou seja, partes que nao entrem em conflito seja ao alterar a mesma posição de memória ao mesmo tempo ou mesmo manter a ordem dos métodos, no caso em que esta seja necessária.\\\\
What	is	the	general	
approach/strategy	you	 followed	 to	have	 the	program	executing	correctly	multithreaded?

\section{Método}
A função mais necessitada de paralelização é a make\textunderscore move visto que é o local onde ocorre a grande parte do tempo de execução do programa, onde são encontrados todos os movimentos possiveis num dado momento e de seguida verificar qual destes o que o jogador deveria escolher para maximizar a sua pontuação. Para paralelizar a obtenção de todos os moves possiveis o trabalho foi dividido por linhas, ou seja, utilizamos um cilk\textunderscore for para cada linha da matriz do tabuleiro de modo a verificar se seria permitida uma jogada nessa mesma posição. Este trabalho poderia ser dividido ainda mais, criando um job para cada posição do tabuleiro no entanto, depois da realização de alguns testes, verificámos que esse tipo de distribuição iria abrandar a execução do programa, visto que a carga de trabalho dentro de cada um seria mínima comparada com a carga necessária para criar um número de jobs tão elevado.
De modo a que cada processo guardasse os seus resultados sem entrar em conflito foi criada uma matriz para guardar os dados de cada movimento.

O outro local onde a paralelização faz sentido, neste programa, seria na procura da melhor jogada possível, de entre todas as possiveis. Para tal foi aplicada uma metodologia semelhante à utilizada anteriormente, na qual é criado um job para cada linha da matriz de movimentos aplicáveis. Desta maneira, cada thread irá tratar de verificar qual a jogada que trará mais ganhos ao utilizador de entre uma subparte da matriz total. De seguida estes serão comparados entre de modo a obter o melhor de todos. Esta paralelização não diminui tanto o tempo de execução como a anterior, visto que os cálculos executados dentro desta são menores que na obtenção dos movimentos possiveis.

Foram realizados vários testes sobre se seria oportuno paralelizar outras partes do código, no entanto em nenhuma delas seriam obtidos ganhos significativos o suficiente para a justificar. Um desses casos seria o cálculo das pontuações finais. No entanto este método apenas vai a cada posição do tabuleiro e verifica qual foi o jogador que colocou uma peça nesta posição. Neste caso não haveriam ganhos suficientes para paralelizar esta implementação visto que a o código executado é mínimo comparado com o necessário para a criação dos jobs, a não ser que o board seja bastante grande, altura em que o programa iria crashar por falta de resources, tentando executar as outras partes do código.




What	parallel	pattern(s)	did	you	use?	 What	problems	did	you	
identify	 when	 parallelizing	 the	 given	 code?	 	 How	 did	 you	 address/solve	 them?	


\section{Validação}
De modo a realizar verificar se o programa irá correr sem problemas foram realizados bastantes testes em diferentes máquinas utilizando flags e inputs diferentes, de modo a tentar testar todos os casos possíveis no qual o programa poderia ser executado.
Isto para um programa implementado sequencialmente talvez seria o suficiente para garantir um elevado nivel de confiança no programa. No entanto, visto que este é executado em paralelo não existe uma certeza da ordem de execução de cada um dos threads. Logo podem existir casos onde o um thread pode se atrasar relativamente a outro, devido a "barulho" existente durante a execução do código. Para poder testar estas ocasiões seria necessário utilizar um "noise injector" de modo a poder simular um ambiente mais real, visto que seria alterada a ordem de finalização de cada thread.

TODO FAZER O TESTE SE TIVER TEMPO

\section{Avaliação}

\section{Conclusões}

\section{Acknowledgments}
\begin{itemize}
\item André Neves - Nº46264
\begin{itemize}
\item Discussão sobre várias maneiras de implementar a paralelização, nomeadamente se seria melhor recursivamente ou iterativamente e sobre os vários padrões de paralelização e sobre qual o mais correto para esta situação.
\end{itemize}
\item Daniel Henriques - Nº46144
\begin{itemize}
\item Realização de testes para verificar quais as operações que valem a pena ser optimizadas, tendo em conta a complexidade e número de operações.
\end{itemize}

\end{itemize}

\section{Bibliografia}

\end{document}